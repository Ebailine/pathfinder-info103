{
  "name": "Contact Finder - Fixed Apify",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "148eaa2e-ca0f-46be-b4f2-647e48c28da7",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "148eaa2e-ca0f-46be-b4f2-647e48c28da7"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"success\": true, \"message\": \"Contact finder started\", \"jobs\": $json.body.jobs.length } }}"
      },
      "id": "respond-immediately",
      "name": "Respond Immediately",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [440, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract payload and prepare for processing\nconst payload = $input.item.json.body;\n\n// HR/recruiting keywords for Apify designation field\nconst hrDesignations = [\n  'HR',\n  'HR manager',\n  'recruiter',\n  'talent',\n  'talent acquisition',\n  'people operations',\n  'people partner',\n  'hiring manager',\n  'executive assistant'\n];\n\nreturn payload.jobs.map(job => {\n  // Extract company LinkedIn URL from job data\n  // We need the company page, not the job posting\n  let companyLinkedInUrl = '';\n  \n  if (job.url && job.url.includes('linkedin.com/company/')) {\n    // If url is already a company page, use it\n    companyLinkedInUrl = job.url;\n  } else if (job.domain) {\n    // Try to construct LinkedIn company URL from domain\n    // e.g., \"solomonpage.com\" -> \"https://linkedin.com/company/solomon-page\"\n    const companySlug = job.domain.replace('.com', '').replace(/[^a-z0-9]/g, '-');\n    companyLinkedInUrl = `https://www.linkedin.com/company/${companySlug}`;\n  } else if (job.company) {\n    // Fallback: construct from company name\n    const companySlug = job.company.toLowerCase().replace(/[^a-z0-9]+/g, '-');\n    companyLinkedInUrl = `https://www.linkedin.com/company/${companySlug}`;\n  }\n  \n  return {\n    json: {\n      userId: payload.userId,\n      userEmail: payload.userEmail,\n      contactsPerJob: payload.contactsPerJob,\n      currentJob: job,\n      companyUrls: [companyLinkedInUrl],\n      designation: hrDesignations,\n      maxResultsPerCompany: 15\n    }\n  };\n});"
      },
      "id": "extract-and-split",
      "name": "Extract & Split Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [640, 300]
    },
    {
      "parameters": {
        "resource": "actor",
        "operation": "run",
        "actorId": "caprolok/linkedin-employees-scraper",
        "runOptions": {
          "waitForFinish": true
        },
        "inputJson": "={\n  \"companyUrls\": {{ JSON.stringify($json.companyUrls) }},\n  \"designation\": {{ JSON.stringify($json.designation) }},\n  \"maxResultsPerCompany\": {{ $json.maxResultsPerCompany }}\n}",
        "additionalFields": {}
      },
      "id": "apify-scrape",
      "name": "Apify - Scrape Employees",
      "type": "@apify/n8n-nodes-apify.apify",
      "typeVersion": 1,
      "position": [840, 300],
      "credentials": {
        "apifyApi": {
          "id": "{{APIFY_CREDENTIAL_ID}}",
          "name": "Apify account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Aggregate Apify results and merge with job context\nconst apifyResults = $input.all();\nconst jobData = $('Extract & Split Jobs').item.json;\n\n// Extract all employees from Apify dataset\nconst employees = apifyResults.map(item => item.json);\n\nconsole.log(`Found ${employees.length} employees from Apify`);\n\n// HR/recruiting keywords\nconst hrKeywords = [\n  'recruit', 'talent acquisition', 'talent partner', 'talent',\n  'hr', 'human resources', 'people operations', 'people partner',\n  'hiring', 'staffing', 'sourcer', 'sourcing'\n];\n\n// Extract keywords from job title for team role matching\nconst positionWords = jobData.currentJob.position.toLowerCase().split(' ');\nconst teamKeywords = positionWords.filter(w => w.length > 3);\n\n// Score each employee\nconst scored = employees.map(emp => {\n  const headline = (emp.headline || emp.position || emp.title || '').toLowerCase();\n  let score = 0;\n  let role = 'other';\n  \n  // HR role (highest priority)\n  const isHR = hrKeywords.some(k => headline.includes(k));\n  if (isHR) {\n    score = 100;\n    role = 'hr';\n  }\n  \n  // Team role (based on job title keywords)\n  const isTeam = teamKeywords.some(k => headline.includes(k));\n  if (isTeam && !isHR) {\n    score = 70;\n    role = 'team';\n  }\n  \n  // Seniority bonus\n  if (headline.includes('senior') || headline.includes('lead') || headline.includes('director') || headline.includes('head')) score += 20;\n  if (headline.includes('manager')) score += 15;\n  \n  // Location match bonus\n  if (emp.location && jobData.currentJob.location) {\n    const empLoc = emp.location.toLowerCase();\n    const jobLoc = jobData.currentJob.location.toLowerCase();\n    if (empLoc.includes(jobLoc) || jobLoc.includes(empLoc)) score += 10;\n  }\n  \n  return { ...emp, score, role };\n});\n\n// Filter and sort\nconst filtered = scored\n  .filter(e => e.score >= 60)\n  .sort((a, b) => b.score - a.score)\n  .slice(0, Math.min(jobData.contactsPerJob, 10));\n\nconsole.log(`Filtered to ${filtered.length} contacts (score >= 60)`);\n\n// Return merged data with FULL job context for OpenAI\nreturn [{\n  json: {\n    userId: jobData.userId,\n    userEmail: jobData.userEmail,\n    currentJob: jobData.currentJob,\n    contactsPerJob: jobData.contactsPerJob,\n    employees: filtered\n  }\n}];"
      },
      "id": "filter-score",
      "name": "Filter & Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1040, 300]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "messages": {
          "values": [
            {
              "content": "={{ \"Rank these LinkedIn contacts for job application outreach.\\n\\nJOB DETAILS:\\nPosition: \" + $json.currentJob.position + \"\\nCompany: \" + $json.currentJob.company + \"\\nLocation: \" + $json.currentJob.location + \"\\n\\nJOB DESCRIPTION:\\n\" + ($json.currentJob.description || 'No description available').substring(0, 1000) + \"\\n\\nCONTACTS TO RANK:\\n\" + JSON.stringify($json.employees.map((e, i) => ({\n  id: i,\n  name: e.fullName || e.name,\n  headline: e.headline || e.position || e.title,\n  location: e.location,\n  preliminaryScore: e.score,\n  roleType: e.role\n})), null, 2) + \"\\n\\nRANK these contacts based on:\\n1. HR/recruiting roles (best for initial outreach)\\n2. Team members in similar roles (good for referrals)\\n3. Seniority level (higher is better)\\n4. Location match with job\\n\\nReturn ONLY a JSON array (no markdown, no code blocks):\\n[{\\\"id\\\": 0, \\\"finalScore\\\": 95, \\\"reasoning\\\": \\\"why this person is best\\\"}]\\n\\nRank all contacts from best to worst.\" }}"
            }
          ]
        },
        "options": {
          "temperature": 0.2
        }
      },
      "id": "openai-rank",
      "name": "OpenAI Rank",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [1240, 300],
      "credentials": {
        "openAiApi": {
          "id": "{{OPENAI_CREDENTIAL_ID}}",
          "name": "OpenAI account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Create final contacts\nconst aiData = $input.item.json;\nconst aiContent = aiData.message?.content || aiData.choices?.[0]?.message?.content || '';\nconst jobData = $('Filter & Score').item.json;\n\nlet ranked = [];\ntry {\n  const jsonMatch = aiContent.match(/\\[.*\\]/s);\n  if (jsonMatch) ranked = JSON.parse(jsonMatch[0]);\n} catch (e) {\n  ranked = jobData.employees.map((e, i) => ({ id: i, finalScore: e.score, reasoning: e.role }));\n}\n\nconst contacts = ranked.map(r => {\n  const emp = jobData.employees[r.id];\n  if (!emp) return null;\n  return {\n    name: emp.fullName || emp.name || 'Unknown',\n    position: emp.headline || emp.position || emp.title || '',\n    email: emp.email || null,\n    company: jobData.currentJob.company,\n    linkedin_url: emp.profileUrl || emp.url || emp.linkedinUrl || null,\n    verified: false,\n    relevance_score: r.finalScore || emp.score || 50,\n    reasoning: r.reasoning || emp.role,\n    source: 'linkedin_apify',\n    role_type: emp.role\n  };\n}).filter(Boolean);\n\nreturn {\n  json: {\n    userId: jobData.userId,\n    applicationId: jobData.currentJob.applicationId,\n    jobId: jobData.currentJob.jobId,\n    company: jobData.currentJob.company,\n    position: jobData.currentJob.position,\n    contacts\n  }\n};"
      },
      "id": "create-contacts",
      "name": "Create Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 300]
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "contacts",
        "returnAll": false,
        "limit": 1000,
        "options": {
          "queryString": "=user_id=eq.{{ $json.userId }}"
        }
      },
      "id": "check-dupes",
      "name": "Check Duplicates",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1640, 300],
      "credentials": {
        "supabaseApi": {
          "id": "{{SUPABASE_CREDENTIAL_ID}}",
          "name": "Supabase account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const newContacts = $('Create Contacts').item.json.contacts;\nconst existing = $input.all().map(i => i.json);\n\nconst existingEmails = new Set(existing.map(c => c.email?.toLowerCase()).filter(Boolean));\nconst existingLinkedIn = new Set(existing.map(c => c.linkedin_url?.toLowerCase()).filter(Boolean));\n\nconst unique = newContacts.filter(c => {\n  if (c.email?.toLowerCase() && existingEmails.has(c.email.toLowerCase())) return false;\n  if (c.linkedin_url?.toLowerCase() && existingLinkedIn.has(c.linkedin_url.toLowerCase())) return false;\n  return true;\n});\n\nreturn {\n  json: {\n    userId: $('Create Contacts').item.json.userId,\n    applicationId: $('Create Contacts').item.json.applicationId,\n    jobId: $('Create Contacts').item.json.jobId,\n    company: $('Create Contacts').item.json.company,\n    position: $('Create Contacts').item.json.position,\n    contacts: unique,\n    totalFound: newContacts.length,\n    duplicatesRemoved: newContacts.length - unique.length,\n    uniqueCount: unique.length\n  }\n};"
      },
      "id": "remove-dupes",
      "name": "Remove Duplicates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1840, 300]
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "sheetName": {
          "__rl": true,
          "mode": "list",
          "value": "Contact Finder Logs"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Timestamp": "={{ $now.toISO() }}",
            "User ID": "={{ $json.userId }}",
            "Job": "={{ $json.position + ' at ' + $json.company }}",
            "Application ID": "={{ $json.applicationId }}",
            "Total": "={{ $json.totalFound }}",
            "Unique": "={{ $json.uniqueCount }}",
            "Dupes": "={{ $json.duplicatesRemoved }}",
            "Names": "={{ $json.contacts.map(c => c.name).slice(0, 5).join(', ') }}"
          }
        },
        "options": {}
      },
      "id": "log-sheets",
      "name": "Log to Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [2040, 300],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "https://sivio.vercel.app/api/contacts/webhook",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "x-webhook-secret",
              "value": "wh_sec_contact_finder_n8n_2025_prod_v1_secure_token_xK9mP3nQ7yR2vL8cF4jH6tS1wN5bG0d"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"user_id\": $json.userId, \"application_id\": $json.applicationId, \"contacts\": $json.contacts } }}",
        "options": {}
      },
      "id": "push-sivio",
      "name": "Push to Sivio",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2240, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [[{"node": "Respond Immediately", "type": "main", "index": 0}]]
    },
    "Respond Immediately": {
      "main": [[{"node": "Extract & Split Jobs", "type": "main", "index": 0}]]
    },
    "Extract & Split Jobs": {
      "main": [[{"node": "Apify - Scrape Employees", "type": "main", "index": 0}]]
    },
    "Apify - Scrape Employees": {
      "main": [[{"node": "Filter & Score", "type": "main", "index": 0}]]
    },
    "Filter & Score": {
      "main": [[{"node": "OpenAI Rank", "type": "main", "index": 0}]]
    },
    "OpenAI Rank": {
      "main": [[{"node": "Create Contacts", "type": "main", "index": 0}]]
    },
    "Create Contacts": {
      "main": [[{"node": "Check Duplicates", "type": "main", "index": 0}]]
    },
    "Check Duplicates": {
      "main": [[{"node": "Remove Duplicates", "type": "main", "index": 0}]]
    },
    "Remove Duplicates": {
      "main": [[{"node": "Log to Sheets", "type": "main", "index": 0}]]
    },
    "Log to Sheets": {
      "main": [[{"node": "Push to Sivio", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-16T00:00:00.000Z",
  "versionId": "6"
}
